{% extends "base.html" %}
{% load static sekizai_tags tutorial_tags %}

{% block addtoblock %}
	{{ block.super }}
	{% addtoblock "js" %}<script src="{% static 'js/djng-forms.js' %}" type="text/javascript"></script>{% endaddtoblock %}
	{% addtoblock "js" %}<script src="{% static 'js/djng-forms-set.js' %}" type="text/javascript"></script>{% endaddtoblock %}
	{% add_data "ng-requires" "djng.forms-set" %}
{% endblock %}

{% block main-content %}

	{% block main-intro %}
	<h1>Django's Forms Set</h1>
	<p class="lead">How to validate a Set of Forms</p>
	<p>This example shows how to validate multiple Forms inside an AngularJS application.</p>
	{% endblock main-intro %}

	<hr />

	<djng-forms-set>
		<div class="row">
			<div class="col-md-12">
				<form name="{{ subscribe_form.form_name }}" novalidate>
					{{ subscribe_form.as_div }}
			{% verbatim %}
				<h5><code>djng-forms-set</code>'s scope:</h5>
				<pre>subscribe_data = {{ subscribe_data | json }}</pre>
			{% endverbatim %}
				</form>
			</div>
		</div>
		<div class="row">
			<div class="col-md-12">
				<form name="{{ address_form.form_name }}" novalidate>
					{{ address_form.as_div }}
				</form>
			</div>
		</div>
		<div class="row" style="margin-bottom: 20px;">
			<div class="col-md-12">
				<button type="submit" class="btn btn-primary">Subscribe Me</button>
			</div>
		</div>
		<div class="row">
			<div class="col-md-12">
			{% verbatim %}
				<h5><code>djng-forms-set</code>'s scope:</h5>
				<pre>subscribe_data = {{ subscribe_data | json }}</pre>
			{% endverbatim %}
			</div>
		</div>
	</djng-forms-set>

	<hr />

	<div class="djng-tutorial" ng-controller="TutorialCtrl">
	<h3>How does it work?</h3>

	{% block main-tutorial %}
	<p>By inheriting from the mixin class <code>Bootstrap3FormMixin</code>, Django renders the form in
	a way, compatible with Twitter Bootstrap. Here the correct CSS classes are added to the
	<code>&lt;input&gt;</code> elements, which are embedded inside
	<code>&lt;div class="form-group"&gt;</code> containers. If you omit <code>Bootstrap3FormMixin</code>,
	then the Form is rendered, as Django would by default.</p>
	<p>When this form is rejected by the server, the list of errors is rendered using AngularJS's built
	in <a href="https://docs.angularjs.org/api/ng/directive/form">Form Controller</a> using the
	directive <code>ng-show="<em>formname.fieldname</em>.$pristine"</code>. This in contrast to Django's
	internal behavior has the advantage, that the field's error message disappears as soon as the
	user starts typing.</p>
	<p>Passwords can, for obvious reasons only be validated by the server. Here for demonstration
	purpose, this is performed by the password field itself, but don't do this in a productive
	environment!</p>

	<p ng-init="tabList=['Form', 'View', 'HTML']"></p>
	{% endblock main-tutorial %}

	<ul class="nav nav-tabs" role="tablist">
		<li ng-repeat="tab in tabList" ng-class="tabClass(tab)">
			<a ng-click="setTab(tab)" ng-bind="tab"></a>
		</li>
	</ul>

	{% block main-sample-code %}
	{% autoescape off %}
	<div ng-show="activeTab==='Form'">{% pygments "forms/forms_set.py" %}</div>
	<div ng-show="activeTab==='View'">{% pygments "views/forms_set.py" %}</div>
	<div ng-show="activeTab==='HTML'">{% pygments "tutorial/forms-set.html" %}</div>
	{% endautoescape %}
	<p class="bg-info">Use this setting, if you want your forms behave the way intended by Django.
	Here the only exception is, that errors from a previous and failed form validation disappear, as
	soon as the user changes that field.<br/>In this setting, AngularJS adds a dummy
	<code>ng-model</code> attribute to each input field.</p>
	{% endblock main-sample-code %}

	</div>

{% endblock main-content %}
